<?php
/**
 * @file
 * Code for the Productivity Github feature.
 */

include_once 'productivity_github.features.inc';

/**
 * Implements hook_menu().
 */
function productivity_github_menu() {
  $items['payload'] = array(
    'page callback' => 'productivity_github_payload',
    'access callback' => TRUE,
  );

  $items['tracking/per-issue'] = array(
    'title' => t('Issue tracking table'),
    'access arguments' => array('access admin panel'),
    'page callback' => 'productivity_github_time_display_tracking_issue_table',
    'type' => MENU_CALLBACK,
    'file' => 'productivity_github.table.inc'
  );

  return $items;
}

/**
 * Create a pull request node when a pull request is opened.
 */
function productivity_github_payload() {
  // Verify payload is in the $_POST array.
  $_POST['payload'] = empty($_POST['payload']) ? file_get_contents("php://input") : $_POST['payload'];

  if (variable_get('productivity_debug_payload', FALSE)) {
    // Debug GitHub request.
    $debug_array = array(
      'post' => $_POST,
      'request' => $_REQUEST,
      'server' => $_SERVER,
    );

    watchdog('productivity', 'Github hook activated, data:\n' . print_r($debug_array, TRUE));
  }

  if (empty($_POST['payload'])) {
    return;
  }

  $payload = json_decode($_POST['payload']);
  $event = isset($_SERVER['HTTP_X_GITHUB_EVENT']) ? $_SERVER['HTTP_X_GITHUB_EVENT'] : FALSE;

  // Allow only specific events.
  $allowed_events = array(
    'issues',
    'pull_request',
  );
  if (!in_array($event, $allowed_events)) {
    watchdog('productivity', t('A not allowed Github API event of type "@event" from the repository "@repo" was sent.', array(
      '@event' => $event,
      '@repo' => $payload->repository->full_name,
    )));
    return;
  }

  $action = $payload->action;

  // Handle the payload in a separate function.
  $function_name = 'productivity_gituhub_payload_handle_' . $event . '_' . $action;
  if (function_exists($function_name)) {
    $function_name($payload);
  }
}

/**
 * Get user ID from the GitHub username.
 *
 * @param string $github_username
 *   A github username.
 *
 * @return int
 *   Account ID.
 */
function productivity_github_get_uid_by_github_username($github_username) {
  if ($uid = _productivity_github_get_entity_id_by_field_value('field_github_username', 'user', $github_username)) {
    return $uid;
  }

  watchdog('productivity', t('No user with github username: @username', array('@username' => $github_username)));
}

/**
 * Get the project ID from the repository name.
 *
 * @param $repository_info
 *  A github repository names.
 *
 * @return int
 *   Project node ID.
 */
function productivity_github_get_project_by_repository($repository_info) {
  // Look for one of the 3 supported name in the following order:
  // $repository_info->name - Project name (ie. generator-hedley)
  // $repository_info->owner->login - Account name (ie. Gizra)
  // $repository_info->full_name - Project name + Account (ie. Gizra/generator-hedley)

  $values = array(
    $repository_info->name,
    $repository_info->owner->login,
    $repository_info->full_name,
  );

  foreach ($values as $value) {
    if ($nid = _productivity_github_get_entity_id_by_field_value('field_github_repository_name', 'project', check_plain($value))) {
      return $nid;
    }
  }
  // Print error if no repo was found.
  watchdog('productivity', t('No project with github repository: @repository', array('@repository' => print_r($repository_info, TRUE))));
}

/**
 * Fetch an entity ID by a unique field value.
 *
 * @param $field
 *   Field name.
 * @param $bundle
 *   Entity bundle.
 * @param $value
 *   Field value.
 *
 * @return int
 *   Entity ID.
 */
function _productivity_github_get_entity_id_by_field_value($field, $bundle, $value) {
  // Using db_select to allow this query for anonymous.
  $result = db_select('field_data_' . $field, 'f')
    ->fields('f', array('entity_id'))
    ->condition('bundle', $bundle)
    ->condition($field . '_value', $value)
    ->range(0, 1)
    ->execute()
    ->fetchAssoc();

  if (!empty($result['entity_id'])) {
    return $result['entity_id'];
  }
}

/**
 * Handle a pull request synchronization.
 *
 * @param $payload
 *   GitHub payload.
 *
 * @see https://developer.github.com/v3/activity/events/types/#pullrequestevent
 */
function productivity_gituhub_payload_handle_pull_request_synchronize($payload) {
  // We need to check if it's the same user an update the same entity, if it's
  // a different user then we need to create a new entity.

  $nid = productivity_github_get_entity_id_by_push_info($payload);
  if ($nid) {
    // Update push dates if the entity exists.
    $wrapper = entity_metadata_wrapper('node', $nid);
    $push_dates = $wrapper->field_push_date->value();

    // Check if the same date have been already submitted (Ignore time).
    // We don't want to create a big list of dates on each commit.
    $date_is_saved = FALSE;
    if (!empty($push_dates)) {
      foreach ($push_dates as $date) {
        $date_formatted = date('d/m/Y', $date);
        $pushed_date_formatted = date('d/m/Y', strtotime($payload->repository->pushed_at));
        watchdog('productivity', 'pushed_date_formmated:' . $pushed_date_formatted);
        watchdog('productivity', 'date_formmated:' . $date_formatted);
        if ($date_formatted == $pushed_date_formatted) {
          $date_is_saved = TRUE;
        }
      }
    }
    if (!$date_is_saved) {
      $push_dates[] = strtotime($payload->repository->pushed_at);
      $wrapper->field_push_date->set($push_dates);
      $wrapper->save();
    }
  }
  else {
    // Create a new entity if a new user has pushed to the pull request.
    productivity_gituhub_payload_handle_pull_request_opened($payload);
  }
}

/**
 * Handle a new pull request.
 *
 * @param $payload
 *   GitHub payload.
 *
 * @see https://developer.github.com/v3/activity/events/types/#pullrequestevent
 */
function productivity_gituhub_payload_handle_pull_request_opened($payload) {
  // When a PR is opened we need to create a new entity.

  // Create the node if there's a user ID.
  $uid = productivity_github_get_uid_by_github_username(check_plain($payload->sender->login));
  if (!$uid) {
    return;
  }

  $node = new stdClass();
  $node->title = check_plain($payload->pull_request->title);
  $node->type = 'github_issue';
  node_object_prepare($node);
  $node->language = LANGUAGE_NONE;
  $node->status = NODE_PUBLISHED;
  $node->uid = $uid;

  $wrapper = entity_metadata_wrapper('node', $node);
  $wrapper->field_employee->set($node->uid);
  $wrapper->field_project->set(productivity_github_get_project_by_repository($payload->repository));
  $wrapper->field_issue_id->set((int)$payload->pull_request->number);
  $wrapper->field_push_date->set(array(strtotime($payload->pull_request->updated_at)));
  $wrapper->field_github_content_type->set('pull_request');

  $project_id = $payload->repository->full_name;
  $wrapper->field_github_project_id->set($project_id);
  $body = $payload->pull_request->body;
  $wrapper->body->value->set($body);

  // Attempt to get an issue number.
  $issue_id = _productivity_github_issue_number_from_body($body);

  if ($issue_id) {
    // Find a local node for the issue.
    $query = new EntityFieldQuery();
    $result = $query
      ->entityCondition('entity_type', 'node')
      ->entityCondition('bundle', 'github_issue')
      ->propertyCondition('status', NODE_PUBLISHED)
      ->fieldCondition('field_issue_id', 'value', $issue_id)
      ->fieldCondition('field_github_project_id', 'value', $project_id)
      ->fieldCondition('field_github_content_type', 'value', 'issue')
      ->range(0, 1)
      ->execute();

    if (!empty($result['node'])) {
      $wrapper->field_issue_reference->set(key($result['node']));
    }
  }

  $wrapper->save();
}

/**
 * Handle a new issue.
 *
 * @param $payload
 *  GitHub payload.
 *
 * @see https://developer.github.com/v3/activity/events/types/#issuesevent
 */
function productivity_gituhub_payload_handle_issues_opened($payload) {
  // Simplify code.
  $data = $payload->issue;

  $title = htmlspecialchars($data->title, ENT_NOQUOTES, 'UTF-8');

  $node = new stdClass();
  $node->title = $title;
  $node->type = 'github_issue';
  node_object_prepare($node);
  $node->language = LANGUAGE_NONE;
  $node->status = NODE_PUBLISHED;
  $node->uid = productivity_github_get_uid_by_github_username(check_plain($data->user->login));

  $wrapper = entity_metadata_wrapper('node', $node);
  $wrapper->body->value->set($data->body);

  $fields = array(
    'field_employee' => $node->uid,
    'field_project' => productivity_github_get_project_by_repository($payload->repository),
    'field_issue_id' => (int)$data->number,
    'field_push_date' => array(strtotime($data->updated_at)),
    'field_github_project_id' => $payload->repository->full_name,
    'field_github_content_type' => 'issue',
  );

  // Get time estimate from title, if it has any.
  $matches = array();
  if (preg_match('/\[([0-9]+)[h|H]\]|\[([0-9]+\.[0-9]+)[h|H]\]/', $title, $matches)) {
    // The iss has a time estimate.
    $time_estimate = empty($matches[1]) ? (empty($matches[2]) ? 0 : $matches[2]) : $matches[1];

    $fields += array(
      'field_time_estimate' => $time_estimate,
    );
  }

  foreach ($fields as $field_name => $field_value) {
    $wrapper->{$field_name}->set($field_value);
  }

  $wrapper->save();
}

/**
 * Get GitHub entity ID from GitHub's API info.
 *
 * @param $payload
 *  The push info from GitHub API.
 *
 * @return mixed
 *  The GitHub entity ID.
 */
function productivity_github_get_entity_id_by_push_info($payload) {
  $uid = productivity_github_get_uid_by_github_username(check_plain($payload->sender->login));
  $issue_id = (int)$payload->pull_request->number;
  $project_id = productivity_github_get_project_by_repository($payload->repository);

  // Check if there's any entity opened already for this pull request (issue)
  // which is referencing the current pusher.
  $query = new EntityFieldQuery();
  $result = $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'github_issue')
    ->propertyCondition('status', NODE_PUBLISHED)
    ->fieldCondition('field_issue_id', 'value', $issue_id)
    ->fieldCondition('field_employee', 'target_id', $uid)
    ->fieldCondition('field_project', 'target_id', $project_id)
    ->range(0, 1)
    ->execute();

  if (!empty($result['node'])) {
    return key($result['node']);
  }
}

/**
 * Get the issue number from the pull request body.
 *
 * @param $text string
 *  Pull request's body.
 *
 * @return number
 *  Issue number in Github.
 */
function _productivity_github_issue_number_from_body($text) {
  $matches = array();
  if (preg_match("/\#([0-9]*)/", $text, $matches)) {

    // Found an issue.
    return intval($matches[1]);
  }

  return FALSE;
}
