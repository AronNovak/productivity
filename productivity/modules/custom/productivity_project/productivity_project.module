<?php
/**
 * @file
 * Code for the Productivity project feature.
 */

include_once 'productivity_project.features.inc';

/**
 * Implements hook_menu().
 */
function productivity_project_menu() {
  $items['recalculate-project-time/%node'] = array(
    'page callback' => 'productivity_project_recalculate_hours',
    'page arguments' => array(1),
    'access callback' => 'productivity_project_recalculate_access',
    'access arguments' => array(1),
    'type' => MENU_CALLBACK,
  );

  $items['repository_autocomplete'] = array(
    'page callback' => 'productivity_project_repository_autocomplete',
    'access callback' => TRUE,
  );

  $items['repository_autocomplete_invalidate'] = array(
    'page callback' => 'productivity_project_repository_autocomplete_invalidate',
    'access callback' => TRUE,
  );

  return $items;
}

/**
 * Implements hook_node_presave().
 */
function productivity_project_node_presave($node) {

}

/**
 * Implements hook_ctools_plugin_directory().
 */
function productivity_project_ctools_plugin_directory($module, $plugin) {
  if ($module == 'ctools') {
    return 'plugins/' . $plugin;
  }
}

/**
 * Access callback; Check permissions for user and the bundle of the entity.
 *
 * @param object $node
 *  The entity.
 * @return bool
 *
 */
function productivity_project_recalculate_access($node) {
  if (!user_access('administer nodes')) {
    return FALSE;
  }

  if ($node->type != 'project') {
    return FALSE;
  }
  return TRUE;
}

/**
 * Page callback; Recalculates the total hours and days of a project from the beginning of time.
 *
 * @param $node
 *  The "project" entity that needs hours recalculation.
 */
function productivity_project_recalculate_hours($node) {
  $wrapper  = entity_metadata_wrapper('node', $node);

  $total = productivity_time_tracking_total_hours($wrapper->getIdentifier());
  $wrapper->field_hours->set($total['hour']);
  $wrapper->field_days->set($total['day']);
  $wrapper->save();
  drupal_goto('node/' . $node->nid);
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Disables the hours and days fields in Project's node edit form.
 */
function productivity_project_form_project_node_form_alter(&$form, &$form_state) {
  $form['field_hours']['#disabled'] = TRUE;
  $form['field_days']['#disabled'] = TRUE;
  $form['field_percentage_notification']['#disabled'] = TRUE;

  // Set the repo name as autocomplete.
  foreach ($form['field_github_repository_name'][LANGUAGE_NONE] as &$element) {
    if (empty($element['value'])) {
      continue;
    }
    $element['value']['#autocomplete_path'] = 'repository_autocomplete';
  }

  $form['field_github_repository_name']['#prefix'] = l(t('Invalidate list of repositories'), 'repository_autocomplete_invalidate', array('query' => array('destination' => $_GET['q'])));
}

/**
 * Notify site managers about logged hours percentage in a project.
 *
 * The notifications percentage thresholds: 25%, 50%, 75%, 95%, 100%.
 * Calculates the percentage from the scope,
 * Checks if the project has reached a new threshold,
 * Sends a message with project details and hours percentage logged.
 *
 * @param object $node
 *  The project node.
 *
 * @return boolean
 *  Returns FALSE only if the scope is not relevant.
 *
 */
function productivity_project_logged_hours_notify($node, $detail_scope) {
  $wrapper = entity_metadata_wrapper('node', $node);
  $total_scope = $wrapper->field_scope->value();

  // Scope hours
  foreach($wrapper->field_table_rate->raw() as $value) {
    if($value['field_issue_type'][LANGUAGE_NONE]['0']['value'] === $detail_scope) {
      $hours = $value['field_hours'][LANGUAGE_NONE]['0']['value'];
      $scope = $value['field_scope'][LANGUAGE_NONE]['0'];
    }
  }

  // Notification thresholds.
  $thresholds = array(
    '100',
    '95',
    '75',
    '50',
    '25',
  );

  // Bypass if the scope period is in months or years.
  if ($total_scope['period'] == 'month' || $total_scope['period'] == 'year') {
    return FALSE;
  }

  $total_hours = $wrapper->field_hours->value();
  $total_days = $wrapper->field_days->value();
  $percentage_notified = $wrapper->field_percentage_notification->value();

  // Calculate the project's percentage of logged hours.
  $total_percentage = productivity_project_calculate_percentage($total_scope, $total_hours);
  $scope_percentage = productivity_project_calculate_percentage($scope, $hours);

  // Send only if the project reached a new threshold and
  // the managers were never notified about it.
  $arguments = array(
    '@project_name' => $wrapper->label(),
    '@logged_percentage' => $total_percentage,
    '@project_scope' => $total_scope['interval'] . ' ' . $total_scope['period'],
    '@project_total_hours' => $total_hours,
    '@project_total_days' => $total_days,
  );
  notify($thresholds, $wrapper, $total_percentage, 'The project @project has reached a new threshold: @threshold%', $percentage_notified, $arguments);

  $arguments = array(
    '@project_name' => $wrapper->label(),
    '@logged_percentage' => $scope_percentage,
    '@project_scope' => $scope['interval'] . ' ' . $scope['period'],
    '@project_total_hours' => $hours,
    '@project_total_days' => $value['field_days'][LANGUAGE_NONE]['0']['value'],
  );
  notify($thresholds, $wrapper, $scope_percentage, 'The @scope in @project project has reached a new threshold: @threshold%', $percentage_notified, $arguments);


}

/**
 * Helper function; Calculates the percentage of logged hours on a given project.
 *
 * @param array $scope
 *  The project's scope with a period.
 * @param int $hours
 *  The total hours logged in a given project.
 *
 * @return int
 *  The calculated percentage of logged hours.
 */
function productivity_project_calculate_percentage($scope, $hours) {
  // Calculate the scope as hours.
  $hours_as_day = variable_get('productivity_time_tracking_hours_count_as_day', 8);
  $scope_in_hours = $scope['period'] == 'hour' ? $scope['interval'] : $scope['interval'] * $hours_as_day;
  return number_format(($hours / $scope_in_hours) * 100, 2);
}

/**
 * Page callback; Return list of the repositories for easy project creation.
 */
function productivity_project_repository_autocomplete($string = '') {

  $repositories = _productivity_project_build_repo_list();

  $results = array();
  foreach ($repositories as $full_name => $name) {
    if ($string && strpos($name, $string) !== FALSE) {
      $results[$full_name] = $name;
    }
  }

  drupal_json_output($results);
}

/**
 * Github API don't allow us search against repos. name. This API function will
 * build a cached version that will be invalidate each day or by a click of a
 * button.
 *
 * @return array
 *   Array of repository name as the key and the full name as the value.
 */
function _productivity_project_build_repo_list() {
  if (!productivity_project_repository_autocomplete_need_invalidate() && $results = variable_get('productivity_project_repositories')) {
    // Return the cached lists of projects.
    return $results;
  }

  $address = 'https://api.github.com/orgs/gizra/repos';
  $results = array();

  list($public, $secret) = array(variable_get('github_public'), variable_get('github_secret'));
  if ($public && $secret) {
    $query = '?client_id=' . $public . '&client_secret='. $secret . '&page=';
  }
  else {
    $query = '?page=';
  }

  $i = 1;
  while (TRUE) {
    // Get the results for the current pagination.
    $data = drupal_http_request($address . $query . $i);

    $output = drupal_json_decode($data->data);

    if ($data->code != 200) {
      $params['@error'] =  implode(' ', $output);
      $message = t('There was a problem requesting the repositories: @error', $params);
      drupal_set_message($message, 'error');
      watchdog('productivity_project', $message);
      break;
    }

    if (!$output) {
      // No more repositories. Break the loop.
      break;
    }

    foreach ($output as $repository) {
      $results[$repository['full_name']] = $repository['name'];
    }

    $i++;
  }

  variable_set('productivity_project_repositories', $results);
  variable_set('productivity_project_repositories_defined', time());
  return $results;
}

/**
 * Invalidating the list of projects.
 */
function productivity_project_repository_autocomplete_invalidate() {
  variable_set('productivity_project_repositories', NULL);
  drupal_set_message(t('The repositories list has been invalidated.'));
  $destination = !empty($_GET['destination']) ? $_GET['destination'] : '<front>';
  drupal_goto($destination);
}

/**
 * Check if we need to invalidate the repositories lists.
 *
 * @return boolean
 */
function productivity_project_repository_autocomplete_need_invalidate() {
  return REQUEST_TIME - variable_get('productivity_project_repositories_defined') >= 86400;
}

/**
 * Update scope days and scope hours if day type is regular.
 *
 * @param $wrapper
 *  The node wrapper.
 * @param $project_wrapper
 *  The original project wrapper.
 *
 * @return string $issue_type
 *  The issue type.
 */
function productivity_project_save_project_details($node) {
  $wrapper = entity_metadata_wrapper('node', $node);
  $project_wrapper = $wrapper->field_project;
  $day_type = $wrapper->field_day_type->value();

  // Add the hours by issue type
  if($day_type === "regular") {
    $table = $project_wrapper->field_table_rate->raw();

    $new_issues = $node->field_issues_logs[LANGUAGE_NONE];
    $old_issues = $node->original->field_issues_logs[LANGUAGE_NONE];
    if (!$old_issues) {
      $old_issues = array();
    }

    for ($index = count($old_issues); $index < count($new_issues); $index++) {
      $type = $new_issues[$index]['field_issue_type'][LANGUAGE_NONE][0]['value'];
      if (check_existing_type($table, $type)) {
        // Existing type, loop through the table types.
        foreach ($table as $table_index => $value) {
          // Check if the it's the same type.
          if ($value['field_issue_type'][LANGUAGE_NONE][0]['value'] === $type) {
            // Get the index of the issue tape in the table
            $next_index = get_table_next_index($table, $type);

            // Add the hours to the existing hours type.
            $table[$next_index]['field_hours'][LANGUAGE_NONE][0]['value'] += $new_issues[$index]['field_time_spent'][LANGUAGE_NONE][0]['value'];
          }
        }
      } else {
        // New type (just insert the new type).
        $id = $new_issues[$index]['id'];
        $days = strval(productivity_time_tracking_total_days($project_wrapper->getIdentifier()));
        $time_spent = $new_issues[$index]['field_time_spent'][LANGUAGE_NONE][0]['value'];
        $issue_type = $type;
        $interval = '0';
        $period = 'hour';
        $amount = '0';
        $currency = 'USD';

        // Get the index of the issue tape in the table
        $next_index = get_table_next_index($table, $type);

        $table[$next_index] = create_table_rate_elm($id, $days, $time_spent, $issue_type, $interval, $period, $amount, $currency);
      }
    }
  }

  return $table;
}

/**
 *
 * Return the index of the type in the table,
 * or the table length if it doesn't exist.
 *
 * @param $table
 *  Table types array
 * @param $issue_type
 *  Type to check in table
 *
 * @return int
 *  The index of the type in table
 */
function get_table_next_index($table, $issue_type) {
  foreach($table as $index => $value) {
    if($value['field_issue_type'][LANGUAGE_NONE][0]['value'] === $issue_type){
      $table_index = $index;
    }
  }

  if(!isset($table_index)) {
    $table_index = count($table);
  }

  return $table_index;
}

/**
 *
 * Check if type is already exist in table rate
 *
 * @param $table_array
 *  Table rate
 * @param $issue_type
 *  Type to check
 *
 * @return bool
 *  True | False
 */
function check_existing_type($table_array, $issue_type) {
  foreach($table_array as $index=>$value) {
    $existing_issues[] = $value['field_issue_type'][LANGUAGE_NONE][0]['value'];
  }
  if(in_array($issue_type, $existing_issues)) {
    return true;
  } else {
    return false;
  }
}

/**
 *
 * Create element array for table rate
 *
 * @param $id
 *  The node ID
 * @param $days
 *  Days
 * @param $time_spent
 *  Time spent in the issue
 * @param $issue_type
 *  Issue hours
 * @param $interval
 *  Time on issue
 * @param $period
 *  Type of time (e.g. Hours)
 * @param $amount
 *  Amount for this issue type
 * @param $currency
 *  Billing currency for this issue type
 *
 * @return array
 *  array element for rate table
 */
function create_table_rate_elm($id, $days, $time_spent, $issue_type, $interval, $period, $amount, $currency) {
  return array(
    'id' => $id,
    'field_days' => array(LANGUAGE_NONE => array(array('value' => $days))),
    'field_hours' => array(LANGUAGE_NONE => array(array('value' => $time_spent))),
    'field_issue_type' => array(LANGUAGE_NONE => array(array('value' => $issue_type))),
    'field_scope' => array(LANGUAGE_NONE => array(array(
      'interval' => $interval,
      'period' => $period,
    ))),
    'field_type_rate' => array(LANGUAGE_NONE => array(array(
      'amount' => $amount,
      'currency' => $currency,
    ))),
  );
}

/**
 *
 * Notify
 *
 * @param array $thresholds
 *  The notification thresholds.
 * @param $wrapper
 *  The project wrapper.
 * @param $percentage
 *  The project's percentage of logged hours.
 * @param $email_string
 *  The string to be sent in the email.
 * @param $percentage_notified
 *  The percentage notified before
 * @param $arguments
 *  The email arguments
 */
function notify($thresholds, $wrapper, $percentage, $email_string, $percentage_notified, $arguments) {
  foreach ($thresholds as $key => $threshold) {
    if ($percentage < $threshold || $percentage_notified >= $threshold) {
      // Didn't reach a threshold OR This threshold has been already notified.
      continue;
    }

    if ($percentage < $percentage_notified) {
      // The current percentage has been already notified.
      continue;
    }

    // Add a message to the log messages.
    if(isset($detail_scope)) {
      $message_details = array('@scope' => $detail_scope);
    }
    $message_details['@project'] = $wrapper->label();
    $message_details['@threshold'] = $threshold;
    watchdog('productivity_project', $email_string, $message_details);


    // Create a message for owners.
    $values = array(
      'uid' => 1,
      'arguments' => $arguments,
    );
    $message = message_create('logged_scope_hours', $values);

    // Send the message to the owners.
    $options = array(
      'mail' =>  variable_get('productivity_time_tracking_managers_email', 'info@gizra.com'),
    );
    message_notify_send_message($message, $options);

    // Send notifications to all the team leads as well.
    if ($wrapper->field_team_leads->value()) {
      foreach ($wrapper->field_team_leads as $team_lead) {
        // Create a new message specified to the team lead.
        $values['uid'] = $team_lead->getIdentifier();
        $message = message_create('logged_project_hours', $values);
        // Send this message to the team lead.
        $options['mail'] = $team_lead->mail->value();
        message_notify_send_message($message, $options);
      }
    }

    // Save the percentage so it won't send the same
    // message again at this threshold.
    $wrapper->field_percentage_notification->set($percentage);
    $wrapper->save();
    // Stop this loop when one notifications has been sent.
    break;
  }
}